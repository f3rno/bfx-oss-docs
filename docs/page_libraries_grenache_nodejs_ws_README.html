<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="css/normalize.css"><link rel="stylesheet" type="text/css" href="css/perfect-scrollbar.css"><link rel="stylesheet" type="text/css" href="css/highlightjs/night-owl.css"><link rel="stylesheet" type="text/css" href="index.css"><title>README | grenache-nodejs-ws</title></head><body><div id="bfx-oss-docs-side-bar"><div id="bfx-oss-docs-side-bar__header"><img src="img/bfx-logo-bg-white.png" alt="Bitfinex" height="63"></div><ul><li><a href="index.html"><p>Home</p></a></li><li><a href="page_md_render_test.html"><p>Markdown Render Test</p></a></li><li><a href="page_libraries_bitfinex_api_py_README.html"><img src="svg/icons/python.svg"><p>bitfinex-api-py</p></a></li><li><a href="page_libraries_bitfinex_api_go_README.html"><img src="svg/icons/go.svg"><p>bitfinex-api-go</p></a></li><li><a href="page_libraries_bfxfixgw_README.html"><img src="svg/icons/go.svg"><p>bfxfixgw</p></a></li><li><a href="page_libraries_bitfinex_api_rb_README.html"><img src="svg/icons/ruby.svg"><p>bitfinex-api-rb</p></a></li><li><a href="page_libraries_bitfinex_api_node_README.html"><img src="svg/icons/nodejs_small.svg"><p>bitfinex-api-node</p></a></li><li><a href="page_libraries_bfx_api_mock_srv_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-mock-srv</p></a></li><li><a href="page_libraries_bfx_api_node_core_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-core</p></a></li><li><a href="page_libraries_bfx_api_node_models_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-models</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_example_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-example</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_managed_candles_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-managed-candles</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_managed_ob_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-managed-ob</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_ob_checksum_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-ob-checksum</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_seq_audit_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-seq-audit</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_wd_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-wd</p></a></li><li><a href="page_libraries_bfx_api_node_rest_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-rest</p></a></li><li><a href="page_libraries_bfx_api_node_util_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-util</p></a></li><li><a href="page_libraries_bfx_api_node_ws1_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-ws1</p></a></li><li><a href="page_libraries_bfx_hf_backtest_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-backtest</p></a></li><li><a href="page_libraries_bfx_hf_chart_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-chart</p></a></li><li><a href="page_libraries_bfx_hf_data_server_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-data-server</p></a></li><li><a href="page_libraries_bfx_hf_ext_plugin_bitfinex_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-ext-plugin-bitfinex</p></a></li><li><a href="page_libraries_bfx_hf_ext_plugin_dummy_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-ext-plugin-dummy</p></a></li><li><a href="page_libraries_bfx_hf_indicators_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-indicators</p></a></li><li><a href="page_libraries_bfx_hf_models_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-models</p></a></li><li><a href="page_libraries_bfx_hf_models_adapter_lowdb_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-models-adapter-lowdb</p></a></li><li><a href="page_libraries_bfx_hf_models_adapter_sql_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-models-adapter-sql</p></a></li><li><a href="page_libraries_bfx_hf_models_adapter_template_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-models-adapter-template</p></a></li><li><a href="page_libraries_bfx_hf_algo_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-algo</p></a></li><li><a href="page_libraries_bfx_hf_server_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-server</p></a></li><li><a href="page_libraries_bfx_hf_strategy_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-strategy</p></a></li><li><a href="page_libraries_bfx_hf_strategy_exec_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-strategy-exec</p></a></li><li><a href="page_libraries_bfx_hf_ui_config_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-ui-config</p></a></li><li><a href="page_libraries_bfx_hf_util_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-util</p></a></li><li><a href="page_libraries_bfx_ws2_api_audit_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-ws2-api-audit</p></a></li><li><a href="page_libraries_cbq_js_README.html"><img src="svg/icons/nodejs_small.svg"><p>cbq-js</p></a></li><li><a href="page_libraries_caron_README.html"><img src="svg/icons/nodejs_small.svg"><p>caron</p></a></li><li><a href="page_libraries_eos_name_verify_README.html"><img src="svg/icons/nodejs_small.svg"><p>eos-name-verify</p></a></li><li><a href="page_libraries_grenache_browser_http_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-browser-http</p></a></li><li><a href="page_libraries_grenache_grape_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-grape</p></a></li><li><a href="page_libraries_grenache_nodejs_base_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-base</p></a></li><li><a href="page_libraries_grenache_nodejs_http_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-http</p></a></li><li><a href="page_libraries_grenache_nodejs_link_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-link</p></a></li><li><a href="page_libraries_grenache_nodejs_utp_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-utp</p></a></li><li class="active"><a href="page_libraries_grenache_nodejs_ws_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-ws</p></a><ul><li class="active"><a href="page_libraries_grenache_nodejs_ws_README.html"><p>- README</p></a></li><li><a href="page_libraries_grenache_nodejs_ws_reference.html"><p>- API Reference</p></a></li></ul></li><li><a href="page_libraries_grenache_nodejs_ws_tls_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-ws-tls</p></a></li><li><a href="page_libraries_lib_js_util_currencies_README.html"><img src="svg/icons/nodejs_small.svg"><p>lib-js-util-currencies</p></a></li><li><a href="page_libraries_lib_js_util_math_README.html"><img src="svg/icons/nodejs_small.svg"><p>lib-js-util-math</p></a></li><li><a href="page_libraries_lib_js_util_number_README.html"><img src="svg/icons/nodejs_small.svg"><p>lib-js-util-number</p></a></li><li><a href="page_libraries_lib_js_util_symbol_README.html"><img src="svg/icons/nodejs_small.svg"><p>lib-js-util-symbol</p></a></li><li><a href="page_libraries_smidgen_README.html"><img src="svg/icons/nodejs_small.svg"><p>smidgen</p></a></li><li><a href="page_libraries_sunbeam_README.html"><img src="svg/icons/nodejs_small.svg"><p>sunbeam</p></a></li><li><a href="page_libraries_wasteland_README.html"><img src="svg/icons/nodejs_small.svg"><p>wasteland</p></a></li></ul></div><div id="bfx-oss-docs-content"><div id="bfx-oss-docs-header-bar"><h2>README</h2><h2>grenache-nodejs-ws</h2></div><div id="bfx-oss-docs-content-wrapper" class="bfx-oss-docs-content-type-api-docs"><div class="bfx-oss-docs-md-content bfx-oss-docs-code-wrapper"><div id="bfx-oss-docs-api-docs-index"><div id="bfx-oss-docs-api-docs-index__inner"><nav class="bfx-oss-docs-md-toc"><ol><li><a href="#grenache-node.js-websocket-implementation">Grenache Node.JS WebSocket implementation</a><ol><li><a href="#ssl-support">SSL Support</a></li><li><a href="#setup">Setup</a><ol><li><a href="#install">Install</a></li><li><a href="#other-requirements">Other Requirements</a></li><li><a href="#examples">Examples</a><ol><li><a href="#rpc-server-%2F-client">RPC Server / Client</a></li><li><a href="#ssl-example">SSL Example</a></li></ol></li></ol></li><li><a href="#api">API</a><ol><li><a href="#class%3A-peerrpcserver">Class: PeerRPCServer</a><ol><li><a href="#event%3A-%E2%80%98request%E2%80%99">Event: ‘request’</a></li><li><a href="#new-peerrpcserver(link%2C-%5Boptions%5D)">new PeerRPCServer(link, [options])</a></li><li><a href="#peer.init()">peer.init()</a></li><li><a href="#peer.transport(%E2%80%98server%E2%80%99)">peer.transport(‘server’)</a></li><li><a href="#peer.listen(port)">peer.listen(port)</a></li><li><a href="#peer.port">peer.port</a></li><li><a href="#example">Example</a></li></ol></li><li><a href="#class%3A-peerrpcclient">Class: PeerRPCClient</a><ol><li><a href="#new-peerrpcclient(link%2C-%5Boptions%5D)">new PeerRPCClient(link, [options])</a></li><li><a href="#peer.init()-2">peer.init()</a></li><li><a href="#peer.map(name%2C-payload%2C-%5Boptions%5D%2C-callback)">peer.map(name, payload, [options], callback)</a></li><li><a href="#peer.request(name%2C-payload%2C-%5Boptions%5D%2C-callback)">peer.request(name, payload, [options], callback)</a></li></ol></li><li><a href="#class%3A-peerpub">Class: PeerPub</a><ol><li><a href="#new-peerpub(link%2C-%5Boptions%5D)">new PeerPub(link, [options])</a></li><li><a href="#peer.init()-3">peer.init()</a></li><li><a href="#peer.transport(%E2%80%98server%E2%80%99)-2">peer.transport(‘server’)</a></li><li><a href="#peer.listen(port)-2">peer.listen(port)</a></li><li><a href="#peer.pub(payload)">peer.pub(payload)</a></li></ol></li><li><a href="#class%3A-peersub">Class: PeerSub</a><ol><li><a href="#new-peersub(link%2C-%5Boptions%5D)">new PeerSub(link, [options])</a></li><li><a href="#.sub(name%2C-%5Boptions%5D)">.sub(name, [options])</a></li><li><a href="#event%3A-%E2%80%98message%E2%80%99">Event: ‘message’</a></li></ol></li></ol></li></ol></li></ol></nav></div></div><h1 id="grenache-node.js-websocket-implementation"><a class="header-anchor" href="#grenache-node.js-websocket-implementation">§</a> <a href="https://github.com/bitfinexcom/grenache">Grenache</a> Node.JS WebSocket implementation</h1><img src="logo.png" width="15%"><p>Grenache is a micro-framework for connecting microservices. Its simple and optimized for performance.</p><p>Internally, Grenache uses Distributed Hash Tables (DHT, known from Bittorrent) for Peer to Peer connections. You can find more details how Grenche internally works at the <a href="https://github.com/bitfinexcom/grenache">Main Project Homepage</a></p><ul><li><a href="#ssl-support">SSL</a></li><li><a href="#setup">Setup</a></li><li><a href="#examples">Examples</a></li><li><a href="#api">API</a></li></ul><h2 id="ssl-support"><a class="header-anchor" href="#ssl-support">§</a> SSL Support</h2><pre><code class="hljs"><span class="hljs-attribute">PeerRPCClient
PeerRPCServer</span>
</code></pre><h2 id="setup"><a class="header-anchor" href="#setup">§</a> Setup</h2><h3 id="install"><a class="header-anchor" href="#install">§</a> Install</h3><pre><code class="hljs">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save grenache-nodejs-ws</span>
</code></pre><h3 id="other-requirements"><a class="header-anchor" href="#other-requirements">§</a> Other Requirements</h3><p>Install <code>Grenache Grape</code>: <a href="https://github.com/bitfinexcom/grenache-grape:">https://github.com/bitfinexcom/grenache-grape:</a></p><pre><code class="hljs language-bash">npm i -g grenache-grape
</code></pre><pre><code class="hljs">// <span class="hljs-string">Start </span>2 <span class="hljs-string">Grapes
</span><span class="hljs-string">grape </span><span class="hljs-built_in">--dp</span> <span class="hljs-string">20001 </span><span class="hljs-built_in">--aph</span> <span class="hljs-string">30001 </span><span class="hljs-built_in">--bn</span> <span class="hljs-string">'127.0.0.1:20002'</span>
<span class="hljs-string">grape </span><span class="hljs-built_in">--dp</span> <span class="hljs-string">20002 </span><span class="hljs-built_in">--aph</span> <span class="hljs-string">40001 </span><span class="hljs-built_in">--bn</span> <span class="hljs-string">'127.0.0.1:20001'</span>
</code></pre><h3 id="examples"><a class="header-anchor" href="#examples">§</a> Examples</h3><h4 id="rpc-server-%2F-client"><a class="header-anchor" href="#rpc-server-%2F-client">§</a> RPC Server / Client</h4><p>This RPC Server example announces a service called <code>rpc_test</code> on the overlay network. When the client makes a request, the client connects to the DHT, the Grapes. They return a list of IPs which announce the service <code>rpc_test</code>. The client then open a direct P2P connection to the service.</p><p>The client sends <code>hello</code> and receives <code>world</code> from the server.</p><p>Internally the DHT is asked for the IP of the server and then the request is done as Peer-to-Peer request via websockets.</p><p><strong>Grape:</strong></p><pre><code class="hljs language-bash">grape --dp 20001 --aph 30001 --bn <span class="hljs-string">'127.0.0.1:20002'</span>
grape --dp 20002 --aph 40001 --bn <span class="hljs-string">'127.0.0.1:20001'</span>
</code></pre><p><strong>Server:</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Link = <span class="hljs-built_in">require</span>(<span class="hljs-string">'grenache-nodejs-link'</span>)

<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> Link({
  <span class="hljs-attr">grape</span>: <span class="hljs-string">'http://127.0.0.1:30001'</span>
})
link.start()

<span class="hljs-keyword">const</span> peer = <span class="hljs-keyword">new</span> PeerRPCServer(link, {})
peer.init()

<span class="hljs-keyword">const</span> service = peer.transport(<span class="hljs-string">'server'</span>)
service.listen(_.random(<span class="hljs-number">1000</span>) + <span class="hljs-number">1024</span>)

setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  link.announce(<span class="hljs-string">'rpc_test'</span>, service.port, {})
}, <span class="hljs-number">1000</span>)

service.on(<span class="hljs-string">'request'</span>, (rid, key, payload, handler) =&gt; {
  <span class="hljs-built_in">console</span>.log(payload) <span class="hljs-comment">// hello</span>
  handler.reply(<span class="hljs-literal">null</span>, <span class="hljs-string">'world'</span>)
})
</code></pre><p><strong>Client:</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Link = <span class="hljs-built_in">require</span>(<span class="hljs-string">'grenache-nodejs-link'</span>)

<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> Link({
  <span class="hljs-attr">grape</span>: <span class="hljs-string">'http://127.0.0.1:30001'</span>
})
link.start()

<span class="hljs-keyword">const</span> peer = <span class="hljs-keyword">new</span> PeerRPCClient(link, {})
peer.init()

peer.request(<span class="hljs-string">'rpc_test'</span>, <span class="hljs-string">'hello'</span>, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span> }, (err, data) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err)
    process.exit(<span class="hljs-number">-1</span>)
  }
  <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// world</span>
})

</code></pre><p><a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/rpc_server.js">Code Server</a> <a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/rpc_client.js">Code Client</a></p><h4 id="ssl-example"><a class="header-anchor" href="#ssl-example">§</a> SSL Example</h4><p>This RPC Server example announces a service called <code>rpc_whitelist_service</code> on the overlay network. When a client tries to connect, we check on the serverside if the certificate fingerprint matches the list of clients that we have whitelisted for connections, using <a href="https://github.com/websockets/ws/blob/62cd03ea3705123136c20eedac1b57559d8ea542/doc/ws.md#new-websocketserveroptions-callback">the verifyClient callback</a>.</p><p>In case of a matching fingerprint, we establish the Websocket connection.</p><p>The certificate data is also passed to the request handlers of the server. That allows us to further define permissions for each client.</p><p>The fingerprint allows us to verify that just certain clients are allowed to run a specific action. In the example the client is allowed to run the <code>ping</code> command, but is not allowed to execute the action <code>deleteHarddisk</code>.</p><p>Behind the scenes the DHT is asked for the IP of the server and then the request is done as Peer-to-Peer request via Websockets.</p><p><strong>Server:</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Link = <span class="hljs-built_in">require</span>(<span class="hljs-string">'grenache-nodejs-link'</span>)

<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> Link({
  <span class="hljs-attr">grape</span>: <span class="hljs-string">'http://127.0.0.1:30001'</span>
})
link.start()

<span class="hljs-comment">// this function is testing the cert before the ws connection</span>
<span class="hljs-comment">// with the client is established.</span>
<span class="hljs-keyword">const</span> VALID_FINGERPRINTS = [
  <span class="hljs-string">'22:48:11:0C:56:E7:49:2B:E9:20:2D:CE:D6:B0:7D:64:F2:32:C8:4B'</span>
]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">verifyClient</span> (<span class="hljs-params">info, cb</span>) </span>{
  <span class="hljs-keyword">const</span> cert = info.req.socket.getPeerCertificate()

  <span class="hljs-keyword">if</span> (VALID_FINGERPRINTS.indexOf(cert.fingerprint) !== <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">return</span> cb(<span class="hljs-literal">true</span>)
  }

  <span class="hljs-keyword">return</span> cb(<span class="hljs-literal">false</span>, <span class="hljs-number">401</span>, <span class="hljs-string">'Forbidden'</span>)
}

<span class="hljs-comment">// bootstrap our server</span>
<span class="hljs-keyword">const</span> opts = {
  <span class="hljs-attr">secure</span>: {
    <span class="hljs-attr">key</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'server-key.pem'</span>)),
    <span class="hljs-attr">cert</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'server-crt.pem'</span>)),
    <span class="hljs-attr">ca</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'ca-crt.pem'</span>)),
    <span class="hljs-attr">requestCert</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// take care, can be dangerous in production!</span>
    <span class="hljs-attr">verifyClient</span>: verifyClient
  }
}
<span class="hljs-keyword">const</span> peer = <span class="hljs-keyword">new</span> PeerRPCServer(
  link,
  opts
)
peer.init()

<span class="hljs-keyword">const</span> service = peer.transport(<span class="hljs-string">'server'</span>)
service.listen(<span class="hljs-number">1337</span>)

setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  link.announce(<span class="hljs-string">'rpc_whitelist_service'</span>, service.port, {})
}, <span class="hljs-number">1000</span>)

<span class="hljs-comment">// this function is used to whitelist certain actions based on</span>
<span class="hljs-comment">// the fingerprint after the tls ws connection has established</span>
<span class="hljs-comment">// nobody is allowed to delete the harddisk, but one client is</span>
<span class="hljs-comment">// allowed to perform the ping action</span>
<span class="hljs-keyword">const</span> permissions = {
  <span class="hljs-attr">deleteHarddisk</span>: [],
  <span class="hljs-attr">ping</span>: [
    <span class="hljs-string">'22:48:11:0C:56:E7:49:2B:E9:20:2D:CE:D6:B0:7D:64:F2:32:C8:4B'</span>
  ]
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAllowedToPerformAction</span> (<span class="hljs-params">action, fingerprint</span>) </span>{
  <span class="hljs-keyword">if</span> (!permissions[action]) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }

  <span class="hljs-keyword">if</span> (permissions[action].indexOf(fingerprint) !== <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}

<span class="hljs-comment">// request handler which checks if the client is allowed to perform the</span>
<span class="hljs-comment">// current action. uses a whitelist and certificate fingerprints</span>
service.on(<span class="hljs-string">'request'</span>, (rid, key, payload, handler, cert) =&gt; {
  <span class="hljs-keyword">if</span> (isAllowedToPerformAction(payload.action, cert.fingerprint)) {
    handler.reply(<span class="hljs-literal">null</span>, payload.action + <span class="hljs-string">' action is allowed for this client'</span>)
    <span class="hljs-keyword">return</span>
  }

  handler.reply(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'forbidden'</span>))
})
</code></pre><p><strong>Client:</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Link = <span class="hljs-built_in">require</span>(<span class="hljs-string">'grenache-nodejs-link'</span>)
<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> Link({
  <span class="hljs-attr">grape</span>: <span class="hljs-string">'http://127.0.0.1:30001'</span>
})

link.start()

<span class="hljs-keyword">const</span> secure = {
  <span class="hljs-attr">key</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'client1-key.pem'</span>)),
  <span class="hljs-attr">cert</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'client1-crt.pem'</span>)),
  <span class="hljs-attr">ca</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'ca-crt.pem'</span>)),
  <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// take care, can be dangerous in production!</span>
}

<span class="hljs-keyword">const</span> peer = <span class="hljs-keyword">new</span> PeerRPCClient(
  link,
  { <span class="hljs-attr">secure</span>: secure }
)

peer.init()

link.on(<span class="hljs-string">'connect'</span>, () =&gt; {
  peer.request(<span class="hljs-string">'rpc_whitelist_service'</span>, { <span class="hljs-attr">action</span>: <span class="hljs-string">'ping'</span> }, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span> }, (err, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(err, data) <span class="hljs-comment">// logs: null 'ping action is allowed for this client'</span>
  })

  <span class="hljs-comment">// errors with forbidden error</span>
  peer.request(<span class="hljs-string">'rpc_whitelist_service'</span>, { <span class="hljs-attr">action</span>: <span class="hljs-string">'deleteHarddisk'</span> }, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span> }, (err, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(err, data) <span class="hljs-comment">// logs: Error: forbidden</span>
  })
})
</code></pre><p><a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/ssl/rpc_cert_whitelist_server.js">Server Code</a><br><a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/ssl/rpc_cert_whitelist_client.js">Client Code</a></p><h2 id="api"><a class="header-anchor" href="#api">§</a> API</h2><h3 id="class%3A-peerrpcserver"><a class="header-anchor" href="#class%3A-peerrpcserver">§</a> Class: PeerRPCServer</h3><h4 id="event%3A-%E2%80%98request%E2%80%99"><a class="header-anchor" href="#event%3A-%E2%80%98request%E2%80%99">§</a> Event: ‘request’</h4><p>Emitted when a request from a RPC client is received.</p><ul><li><code>rid</code> unique request id</li><li><code>key</code> name of the service</li><li><code>payload</code> Payload sent by client</li><li><code>handler</code> Handler object, used to reply to a client.</li></ul><pre><code class="hljs language-js">service.on(<span class="hljs-string">'request'</span>, (rid, key, payload, handler) =&gt; {
  handler.reply(<span class="hljs-literal">null</span>, <span class="hljs-string">'world'</span>)
})
</code></pre><h4 id="new-peerrpcserver(link%2C-%5Boptions%5D)"><a class="header-anchor" href="#new-peerrpcserver(link%2C-%5Boptions%5D)">§</a> new PeerRPCServer(link, [options])</h4><ul><li><code>link &lt;Object&gt;</code> Instance of a <a href="#new-linkoptions">Link Class</a></li><li><code>options &lt;Object&gt;</code><ul><li><code>secure &lt;Object&gt;</code> TLS options<ul><li><code>key &lt;Buffer&gt;</code> Key file content</li><li><code>cert &lt;Buffer&gt;</code> Cert file content</li><li><code>ca &lt;Buffer&gt;</code> Ca file content</li><li><code>rejectUnauthorized &lt;Boolean&gt;</code> Reject IPs / Hostnames not in cert’s list</li><li><code>requestCert &lt;Boolean&gt;</code> Request a certificate from a connecting client</li><li><code>verifyClient &lt;Function&gt;</code> Function to verify connecting client before Websocket connection is established.</li></ul></li></ul></li></ul><p>Creates a new instance of a <code>PeerRPCServer</code>, which connects to the DHT using the passed <code>link</code>.</p><h4 id="peer.init()"><a class="header-anchor" href="#peer.init()">§</a> peer.init()</h4><p>Sets the peer active. Must get called before we get a transport to set up a server.</p><h4 id="peer.transport(%E2%80%98server%E2%80%99)"><a class="header-anchor" href="#peer.transport(%E2%80%98server%E2%80%99)">§</a> peer.transport(‘server’)</h4><p>Must get called after the peer is active. Sets peer into server- mode.</p><h4 id="peer.listen(port)"><a class="header-anchor" href="#peer.listen(port)">§</a> peer.listen(port)</h4><p>Lets the <code>PeerRPCServer</code> listen on the desired <code>port</code>. The port is stored in the DHT.</p><h4 id="peer.port"><a class="header-anchor" href="#peer.port">§</a> peer.port</h4><p>Port of the server (set by <code>listen(port)</code>).</p><h4 id="example"><a class="header-anchor" href="#example">§</a> Example</h4><p>This RPC Server example announces a service called <code>rpc_test</code> on the overlay network. When a request from a client is received, it replies with <code>world</code>. It receives the payload <code>hello</code> from the client.</p><p>The client sends <code>hello</code> and receives <code>world</code> from the server.</p><p>Internally the DHT is asked for the IP of the server and then the request is done as Peer-to-Peer request via websockets.</p><p><strong>Server:</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Link = <span class="hljs-built_in">require</span>(<span class="hljs-string">'grenache-nodejs-link'</span>)

<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> Link({
  <span class="hljs-attr">grape</span>: <span class="hljs-string">'http://127.0.0.1:30001'</span>
})
link.start()

<span class="hljs-keyword">const</span> peer = <span class="hljs-keyword">new</span> PeerRPCServer(link, {})
peer.init()

<span class="hljs-keyword">const</span> service = peer.transport(<span class="hljs-string">'server'</span>)
service.listen(_.random(<span class="hljs-number">1000</span>) + <span class="hljs-number">1024</span>)

setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  link.announce(<span class="hljs-string">'rpc_test'</span>, service.port, {})
}, <span class="hljs-number">1000</span>)

service.on(<span class="hljs-string">'request'</span>, (rid, key, payload, handler) =&gt; {
  <span class="hljs-built_in">console</span>.log(payload) <span class="hljs-comment">// hello</span>
  handler.reply(<span class="hljs-literal">null</span>, <span class="hljs-string">'world'</span>)
})
</code></pre><p><strong>Client:</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Link = <span class="hljs-built_in">require</span>(<span class="hljs-string">'grenache-nodejs-link'</span>)

<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> Link({
  <span class="hljs-attr">grape</span>: <span class="hljs-string">'http://127.0.0.1:30001'</span>
})
link.start()

<span class="hljs-keyword">const</span> peer = <span class="hljs-keyword">new</span> PeerRPCClient(link, {})
peer.init()

peer.request(<span class="hljs-string">'rpc_test'</span>, <span class="hljs-string">'hello'</span>, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span> }, (err, data) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err)
    process.exit(<span class="hljs-number">-1</span>)
  }
  <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// world</span>
})

</code></pre><p><a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/rpc_server.js">Server</a> <a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/rpc_client.js">Client</a></p><h3 id="class%3A-peerrpcclient"><a class="header-anchor" href="#class%3A-peerrpcclient">§</a> Class: PeerRPCClient</h3><h4 id="new-peerrpcclient(link%2C-%5Boptions%5D)"><a class="header-anchor" href="#new-peerrpcclient(link%2C-%5Boptions%5D)">§</a> new PeerRPCClient(link, [options])</h4><ul><li><code>link &lt;Object&gt;</code> Instance of a <a href="#new-linkoptions">Link Class</a></li><li><code>options &lt;Object&gt;</code><ul><li><code>maxActiveKeyDests &lt;Number&gt;</code></li><li><code>maxActiveDestTransports &lt;Number&gt;</code></li></ul></li></ul><p>Creates a new instance of a <code>PeerRPCClient</code>, which connects to the DHT using the passed <code>link</code>.</p><p>A PeerRPCClient can communicate with multiple Servers and map work items over them. With <code>maxActiveKeyDests</code> you can limit the maximum amount of destinations. Additionally, you can limit the amount of transports with <code>maxActiveDestTransports</code>.</p><h4 id="peer.init()-2"><a class="header-anchor" href="#peer.init()-2">§</a> peer.init()</h4><p>Sets the peer active. Must get called before we start to make requests.</p><h4 id="peer.map(name%2C-payload%2C-%5Boptions%5D%2C-callback)"><a class="header-anchor" href="#peer.map(name%2C-payload%2C-%5Boptions%5D%2C-callback)">§</a> peer.map(name, payload, [options], callback)</h4><ul><li><code>name &lt;String&gt;</code> Name of the service to address</li><li><code>payload &lt;String&gt;</code> Payload to send</li><li><code>options &lt;Object&gt;</code> Options for the request<ul><li><code>timeout &lt;Number&gt;</code> timeout in ms</li><li><code>limit &lt;Number&gt;</code> maximum requests per available worker</li></ul></li><li><code>callback &lt;Function&gt;</code></li></ul><p>Maps a number of requests over the amount of registered workers / PeerRPCServers. <a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/rpc_client_map.js">Example</a>.</p><h4 id="peer.request(name%2C-payload%2C-%5Boptions%5D%2C-callback)"><a class="header-anchor" href="#peer.request(name%2C-payload%2C-%5Boptions%5D%2C-callback)">§</a> peer.request(name, payload, [options], callback)</h4><ul><li><code>name &lt;String&gt;</code> Name of the service to address</li><li><code>payload &lt;String&gt;</code> Payload to send</li><li><code>options &lt;Object&gt;</code> Options for the request<ul><li><code>timeout &lt;Number&gt;</code> timeout in ms</li><li><code>retry &lt;Number&gt;</code> attempts to make before giving up. default is 1</li></ul></li><li><code>callback &lt;Function&gt;</code></li></ul><p>Sends a single request to a RPC server/worker. <a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/rpc_client.js">Example</a>.</p><h3 id="class%3A-peerpub"><a class="header-anchor" href="#class%3A-peerpub">§</a> Class: PeerPub</h3><h4 id="new-peerpub(link%2C-%5Boptions%5D)"><a class="header-anchor" href="#new-peerpub(link%2C-%5Boptions%5D)">§</a> new PeerPub(link, [options])</h4><ul><li><code>link &lt;Object&gt;</code> Instance of a <a href="#new-linkoptions">Link Class</a></li><li><code>options &lt;Object&gt;</code></li></ul><h4 id="peer.init()-3"><a class="header-anchor" href="#peer.init()-3">§</a> peer.init()</h4><p>Sets the peer active. Must get called before we get a transport to set up a server.</p><h4 id="peer.transport(%E2%80%98server%E2%80%99)-2"><a class="header-anchor" href="#peer.transport(%E2%80%98server%E2%80%99)-2">§</a> peer.transport(‘server’)</h4><p>Must get called after the peer is active. Sets peer into server- mode.</p><h4 id="peer.listen(port)-2"><a class="header-anchor" href="#peer.listen(port)-2">§</a> peer.listen(port)</h4><p>Lets the <code>PeerRPCServer</code> listen on the desired <code>port</code>. The port is stored in the DHT.</p><h4 id="peer.pub(payload)"><a class="header-anchor" href="#peer.pub(payload)">§</a> peer.pub(payload)</h4><ul><li><code>payload &lt;String&gt;</code> Payload to send</li></ul><p>Sends a message to all connected peers. <a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/pub.js">Example</a>.</p><h3 id="class%3A-peersub"><a class="header-anchor" href="#class%3A-peersub">§</a> Class: PeerSub</h3><h4 id="new-peersub(link%2C-%5Boptions%5D)"><a class="header-anchor" href="#new-peersub(link%2C-%5Boptions%5D)">§</a> new PeerSub(link, [options])</h4><ul><li><code>link &lt;Object&gt;</code> Instance of a <a href="#new-linkoptions">Link Class</a></li><li><code>options &lt;Object&gt;</code></li></ul><p>Creates a new instance of a <code>PeerSub</code>, which connects to the DHT using the passed <code>link</code>.</p><h4 id=".sub(name%2C-%5Boptions%5D)"><a class="header-anchor" href="#.sub(name%2C-%5Boptions%5D)">§</a> .sub(name, [options])</h4><ul><li><code>name &lt;String&gt;</code> Name of the Pub Channel to register</li><li><code>options &lt;Object&gt;</code> Options for the request<ul><li><code>timeout &lt;Number&gt;</code> timeout in ms</li></ul></li></ul><p>Registers as a receiver for messages. <a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/sub.js">Example</a>.</p><h4 id="event%3A-%E2%80%98message%E2%80%99"><a class="header-anchor" href="#event%3A-%E2%80%98message%E2%80%99">§</a> Event: ‘message’</h4><p>Emitted when a payload is received.</p></div></div><!--
      <div id="bfx-oss-docs-footer-bar">
        <div id="bfx-oss-docs-footer-bar__container">
          <p>Copyright © 2013-2020 iFinex Inc. All rights reserved.</p>
        </div>
      </div>
      --></div><script type="text/javascript" src="js/vendor/debug.min.js"></script><script type="text/javascript" src="js/vendor/lodash.min.js"></script><script type="text/javascript" src="js/vendor/zepto.min.js"></script><script type="text/javascript" src="js/vendor/perfect-scrollbar.min.js"></script><script type="text/javascript" src="js/main.js"></script></body></html>