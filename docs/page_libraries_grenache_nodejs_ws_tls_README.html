<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="css/normalize.css"><link rel="stylesheet" type="text/css" href="css/perfect-scrollbar.css"><link rel="stylesheet" type="text/css" href="css/highlightjs/night-owl.css"><link rel="stylesheet" type="text/css" href="index.css"><title>README | grenache-nodejs-ws-tls</title></head><body><div id="bfx-oss-docs-side-bar"><div id="bfx-oss-docs-side-bar__header"><img src="img/bfx-logo-bg-white.png" alt="Bitfinex" height="63"></div><ul><li><a href="index.html"><p>Home</p></a></li><li><a href="page_md_render_test.html"><p>Markdown Render Test</p></a></li><li><a href="page_libraries_bitfinex_api_py_README.html"><img src="svg/icons/python.svg"><p>bitfinex-api-py</p></a></li><li><a href="page_libraries_bitfinex_api_go_README.html"><img src="svg/icons/go.svg"><p>bitfinex-api-go</p></a></li><li><a href="page_libraries_bfxfixgw_README.html"><img src="svg/icons/go.svg"><p>bfxfixgw</p></a></li><li><a href="page_libraries_bitfinex_api_rb_README.html"><img src="svg/icons/ruby.svg"><p>bitfinex-api-rb</p></a></li><li><a href="page_libraries_bitfinex_api_node_README.html"><img src="svg/icons/nodejs_small.svg"><p>bitfinex-api-node</p></a></li><li><a href="page_libraries_bfx_api_mock_srv_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-mock-srv</p></a></li><li><a href="page_libraries_bfx_api_node_core_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-core</p></a></li><li><a href="page_libraries_bfx_api_node_models_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-models</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_example_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-example</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_managed_candles_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-managed-candles</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_managed_ob_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-managed-ob</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_ob_checksum_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-ob-checksum</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_seq_audit_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-seq-audit</p></a></li><li><a href="page_libraries_bfx_api_node_plugin_wd_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-plugin-wd</p></a></li><li><a href="page_libraries_bfx_api_node_rest_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-rest</p></a></li><li><a href="page_libraries_bfx_api_node_util_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-util</p></a></li><li><a href="page_libraries_bfx_api_node_ws1_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-api-node-ws1</p></a></li><li><a href="page_libraries_bfx_hf_backtest_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-backtest</p></a></li><li><a href="page_libraries_bfx_hf_chart_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-chart</p></a></li><li><a href="page_libraries_bfx_hf_data_server_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-data-server</p></a></li><li><a href="page_libraries_bfx_hf_ext_plugin_bitfinex_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-ext-plugin-bitfinex</p></a></li><li><a href="page_libraries_bfx_hf_ext_plugin_dummy_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-ext-plugin-dummy</p></a></li><li><a href="page_libraries_bfx_hf_indicators_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-indicators</p></a></li><li><a href="page_libraries_bfx_hf_models_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-models</p></a></li><li><a href="page_libraries_bfx_hf_models_adapter_lowdb_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-models-adapter-lowdb</p></a></li><li><a href="page_libraries_bfx_hf_models_adapter_sql_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-models-adapter-sql</p></a></li><li><a href="page_libraries_bfx_hf_models_adapter_template_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-models-adapter-template</p></a></li><li><a href="page_libraries_bfx_hf_algo_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-algo</p></a></li><li><a href="page_libraries_bfx_hf_server_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-server</p></a></li><li><a href="page_libraries_bfx_hf_strategy_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-strategy</p></a></li><li><a href="page_libraries_bfx_hf_strategy_exec_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-strategy-exec</p></a></li><li><a href="page_libraries_bfx_hf_ui_config_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-ui-config</p></a></li><li><a href="page_libraries_bfx_hf_util_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-hf-util</p></a></li><li><a href="page_libraries_bfx_ws2_api_audit_README.html"><img src="svg/icons/nodejs_small.svg"><p>bfx-ws2-api-audit</p></a></li><li><a href="page_libraries_cbq_js_README.html"><img src="svg/icons/nodejs_small.svg"><p>cbq-js</p></a></li><li><a href="page_libraries_caron_README.html"><img src="svg/icons/nodejs_small.svg"><p>caron</p></a></li><li><a href="page_libraries_eos_name_verify_README.html"><img src="svg/icons/nodejs_small.svg"><p>eos-name-verify</p></a></li><li><a href="page_libraries_grenache_browser_http_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-browser-http</p></a></li><li><a href="page_libraries_grenache_grape_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-grape</p></a></li><li><a href="page_libraries_grenache_nodejs_base_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-base</p></a></li><li><a href="page_libraries_grenache_nodejs_http_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-http</p></a></li><li><a href="page_libraries_grenache_nodejs_link_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-link</p></a></li><li><a href="page_libraries_grenache_nodejs_utp_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-utp</p></a></li><li><a href="page_libraries_grenache_nodejs_ws_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-ws</p></a></li><li class="active"><a href="page_libraries_grenache_nodejs_ws_tls_README.html"><img src="svg/icons/nodejs_small.svg"><p>grenache-nodejs-ws-tls</p></a><ul><li class="active"><a href="page_libraries_grenache_nodejs_ws_tls_README.html"><p>- README</p></a></li><li><a href="page_libraries_grenache_nodejs_ws_tls_reference.html"><p>- API Reference</p></a></li></ul></li><li><a href="page_libraries_lib_js_util_currencies_README.html"><img src="svg/icons/nodejs_small.svg"><p>lib-js-util-currencies</p></a></li><li><a href="page_libraries_lib_js_util_math_README.html"><img src="svg/icons/nodejs_small.svg"><p>lib-js-util-math</p></a></li><li><a href="page_libraries_lib_js_util_number_README.html"><img src="svg/icons/nodejs_small.svg"><p>lib-js-util-number</p></a></li><li><a href="page_libraries_lib_js_util_symbol_README.html"><img src="svg/icons/nodejs_small.svg"><p>lib-js-util-symbol</p></a></li><li><a href="page_libraries_smidgen_README.html"><img src="svg/icons/nodejs_small.svg"><p>smidgen</p></a></li><li><a href="page_libraries_sunbeam_README.html"><img src="svg/icons/nodejs_small.svg"><p>sunbeam</p></a></li><li><a href="page_libraries_wasteland_README.html"><img src="svg/icons/nodejs_small.svg"><p>wasteland</p></a></li></ul></div><div id="bfx-oss-docs-content"><div id="bfx-oss-docs-header-bar"><h2>README</h2><h2>grenache-nodejs-ws-tls</h2></div><div id="bfx-oss-docs-content-wrapper" class="bfx-oss-docs-content-type-api-docs"><div class="bfx-oss-docs-md-content bfx-oss-docs-code-wrapper"><div id="bfx-oss-docs-api-docs-index"><div id="bfx-oss-docs-api-docs-index__inner"><nav class="bfx-oss-docs-md-toc"><ol><li><a href="#grenache-nodejs-ws-tls">grenache-nodejs-ws-tls</a><ol><li><a href="#deprecated!-grenache-nodejs-ws-tls-is-part-of-grenache-nodejs-ws-now.">deprecated! grenache-nodejs-ws-tls is part of grenache-nodejs-ws now.</a></li><li><a href="#currently-supported">Currently Supported</a></li><li><a href="#example">Example</a></li><li><a href="#api">API</a><ol><li><a href="#class%3A-peerrpcserver">Class: PeerRPCServer</a><ol><li><a href="#event%3A-%E2%80%98request%E2%80%99">Event: ‘request’</a></li><li><a href="#new-peerrpcserver(link%2C-%5Boptions%5D)">new PeerRPCServer(link, [options])</a></li><li><a href="#peer.init()">peer.init()</a></li><li><a href="#peer.transport(%E2%80%98server%E2%80%99)">peer.transport(‘server’)</a></li><li><a href="#peer.listen(port)">peer.listen(port)</a></li><li><a href="#peer.port">peer.port</a></li></ol></li><li><a href="#class%3A-peerrpcclient">Class: PeerRPCClient</a><ol><li><a href="#new-peerrpcclient(link%2C-%5Boptions%5D)">new PeerRPCClient(link, [options])</a></li><li><a href="#peer.init()-2">peer.init()</a></li><li><a href="#peer.map(name%2C-payload%2C-%5Boptions%5D%2C-callback)">peer.map(name, payload, [options], callback)</a></li><li><a href="#peer.request(name%2C-payload%2C-%5Boptions%5D%2C-callback)">peer.request(name, payload, [options], callback)</a></li></ol></li></ol></li></ol></li></ol></nav></div></div><h1 id="grenache-nodejs-ws-tls"><a class="header-anchor" href="#grenache-nodejs-ws-tls">§</a> grenache-nodejs-ws-tls</h1><img src="logo.png" width="15%"><h2 id="deprecated!-grenache-nodejs-ws-tls-is-part-of-grenache-nodejs-ws-now."><a class="header-anchor" href="#deprecated!-grenache-nodejs-ws-tls-is-part-of-grenache-nodejs-ws-now.">§</a> deprecated! grenache-nodejs-ws-tls is part of <a href="https://github.com/bitfinexcom/grenache-nodejs-ws">grenache-nodejs-ws</a> now.</h2><p><a href="https://github.com/bitfinexcom/grenache-nodejs-ws">grenache-nodejs-ws</a> with TLS support and optional payload validation based on client certificate.</p><p>Grenache is a micro-framework for connecting microservices. Its simple and optimized for performance.</p><p>Internally, Grenache uses Distributed Hash Tables (DHT, known from Bittorrent) for Peer to Peer connections. You can find more details how Grenche internally works at the <a href="https://github.com/bitfinexcom/grenache">Main Project Homepage</a>.</p><ul><li><a href="#currently-supported">Currently Supported</a></li><li><a href="#example">Example</a></li><li><a href="#api">API</a></li></ul><h2 id="currently-supported"><a class="header-anchor" href="#currently-supported">§</a> Currently Supported</h2><pre><code class="hljs"><span class="hljs-attribute">PeerRPCClient
PeerRPCServer</span>
</code></pre><h2 id="example"><a class="header-anchor" href="#example">§</a> Example</h2><p>This RPC Server example announces a service called <code>rpc_whitelist_service</code> on the overlay network. When a client tries to connect, we check on the serverside if the certificate fingerprint matches the list of clients that we have whitelisted for connections, using <a href="https://github.com/websockets/ws/blob/62cd03ea3705123136c20eedac1b57559d8ea542/doc/ws.md#new-websocketserveroptions-callback">the verifyClient callback</a>.</p><p>In case of a matching fingerprint, we establish the Websocket connection.</p><p>The certificate data is also passed to the request handlers of the server. That allows us to further define permissions for each client.</p><p>The fingerprint allows us to verify that just certain clients are allowed to run a specific action. In the example the client is allowed to run the <code>ping</code> command, but is not allowed to execute the action <code>deleteHarddisk</code>.</p><p>Behind the scenes the DHT is asked for the IP of the server and then the request is done as Peer-to-Peer request via Websockets.</p><p><strong>Server:</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Link = <span class="hljs-built_in">require</span>(<span class="hljs-string">'grenache-nodejs-link'</span>)

<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> Link({
  <span class="hljs-attr">grape</span>: <span class="hljs-string">'http://127.0.0.1:30001'</span>
})
link.start()

<span class="hljs-comment">// this function is testing the cert before the ws connection</span>
<span class="hljs-comment">// with the client is established.</span>
<span class="hljs-keyword">const</span> VALID_FINGERPRINTS = [
  <span class="hljs-string">'22:48:11:0C:56:E7:49:2B:E9:20:2D:CE:D6:B0:7D:64:F2:32:C8:4B'</span>
]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">verifyClient</span> (<span class="hljs-params">info, cb</span>) </span>{
  <span class="hljs-keyword">const</span> cert = info.req.socket.getPeerCertificate()

  <span class="hljs-keyword">if</span> (VALID_FINGERPRINTS.indexOf(cert.fingerprint) !== <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">return</span> cb(<span class="hljs-literal">true</span>)
  }

  <span class="hljs-keyword">return</span> cb(<span class="hljs-literal">false</span>, <span class="hljs-number">401</span>, <span class="hljs-string">'Forbidden'</span>)
}

<span class="hljs-comment">// bootstrap our server</span>
<span class="hljs-keyword">const</span> opts = {
  <span class="hljs-attr">secure</span>: {
    <span class="hljs-attr">key</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'server-key.pem'</span>)),
    <span class="hljs-attr">cert</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'server-crt.pem'</span>)),
    <span class="hljs-attr">ca</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'ca-crt.pem'</span>)),
    <span class="hljs-attr">requestCert</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// take care, can be dangerous in production!</span>
    <span class="hljs-attr">verifyClient</span>: verifyClient
  }
}
<span class="hljs-keyword">const</span> peer = <span class="hljs-keyword">new</span> PeerRPCServer(
  link,
  opts
)
peer.init()

<span class="hljs-keyword">const</span> service = peer.transport(<span class="hljs-string">'server'</span>)
service.listen(<span class="hljs-number">1337</span>)

setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  link.announce(<span class="hljs-string">'rpc_whitelist_service'</span>, service.port, {})
}, <span class="hljs-number">1000</span>)

<span class="hljs-comment">// this function is used to whitelist certain actions based on</span>
<span class="hljs-comment">// the fingerprint after the tls ws connection has established</span>
<span class="hljs-comment">// nobody is allowed to delete the harddisk, but one client is</span>
<span class="hljs-comment">// allowed to perform the ping action</span>
<span class="hljs-keyword">const</span> permissions = {
  <span class="hljs-attr">deleteHarddisk</span>: [],
  <span class="hljs-attr">ping</span>: [
    <span class="hljs-string">'22:48:11:0C:56:E7:49:2B:E9:20:2D:CE:D6:B0:7D:64:F2:32:C8:4B'</span>
  ]
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAllowedToPerformAction</span> (<span class="hljs-params">action, fingerprint</span>) </span>{
  <span class="hljs-keyword">if</span> (!permissions[action]) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }

  <span class="hljs-keyword">if</span> (permissions[action].indexOf(fingerprint) !== <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}

<span class="hljs-comment">// request handler which checks if the client is allowed to perform the</span>
<span class="hljs-comment">// current action. uses a whitelist and certificate fingerprints</span>
service.on(<span class="hljs-string">'request'</span>, (rid, key, payload, handler, cert) =&gt; {
  <span class="hljs-keyword">if</span> (isAllowedToPerformAction(payload.action, cert.fingerprint)) {
    handler.reply(<span class="hljs-literal">null</span>, payload.action + <span class="hljs-string">' action is allowed for this client'</span>)
    <span class="hljs-keyword">return</span>
  }

  handler.reply(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'forbidden'</span>))
})
</code></pre><p><strong>Client:</strong></p><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Link = <span class="hljs-built_in">require</span>(<span class="hljs-string">'grenache-nodejs-link'</span>)
<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> Link({
  <span class="hljs-attr">grape</span>: <span class="hljs-string">'http://127.0.0.1:30001'</span>
})

link.start()

<span class="hljs-keyword">const</span> secure = {
  <span class="hljs-attr">key</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'client1-key.pem'</span>)),
  <span class="hljs-attr">cert</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'client1-crt.pem'</span>)),
  <span class="hljs-attr">ca</span>: fs.readFileSync(path.join(__dirname, <span class="hljs-string">'certs'</span>, <span class="hljs-string">'ca-crt.pem'</span>)),
  <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// take care, can be dangerous in production!</span>
}

<span class="hljs-keyword">const</span> peer = <span class="hljs-keyword">new</span> PeerRPCClient(
  link,
  { <span class="hljs-attr">secure</span>: secure }
)

peer.init()

link.on(<span class="hljs-string">'connect'</span>, () =&gt; {
  peer.request(<span class="hljs-string">'rpc_whitelist_service'</span>, { <span class="hljs-attr">action</span>: <span class="hljs-string">'ping'</span> }, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span> }, (err, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(err, data) <span class="hljs-comment">// logs: null 'ping action is allowed for this client'</span>
  })

  <span class="hljs-comment">// errors with forbidden error</span>
  peer.request(<span class="hljs-string">'rpc_whitelist_service'</span>, { <span class="hljs-attr">action</span>: <span class="hljs-string">'deleteHarddisk'</span> }, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span> }, (err, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(err, data) <span class="hljs-comment">// logs: Error: forbidden</span>
  })
})
</code></pre><p><a href="https://github.com/bitfinexcom/grenache-nodejs-ws-tls/tree/master/examples/rpc_cert_whitelist_server.js">Server Code</a><br><a href="https://github.com/bitfinexcom/grenache-nodejs-ws-tls/tree/master/examples/rpc_cert_whitelist_client.js">Client Code</a></p><h2 id="api"><a class="header-anchor" href="#api">§</a> API</h2><h3 id="class%3A-peerrpcserver"><a class="header-anchor" href="#class%3A-peerrpcserver">§</a> Class: PeerRPCServer</h3><h4 id="event%3A-%E2%80%98request%E2%80%99"><a class="header-anchor" href="#event%3A-%E2%80%98request%E2%80%99">§</a> Event: ‘request’</h4><p>Emitted when a request from a RPC client is received.</p><ul><li><code>rid</code> unique request id</li><li><code>key</code> name of the service</li><li><code>payload</code> Payload sent by client</li><li><code>handler</code> Handler object, used to reply to a client.</li></ul><pre><code class="hljs language-js">service.on(<span class="hljs-string">'request'</span>, (rid, key, payload, handler) =&gt; {
  handler.reply(<span class="hljs-literal">null</span>, <span class="hljs-string">'world'</span>)
})
</code></pre><h4 id="new-peerrpcserver(link%2C-%5Boptions%5D)"><a class="header-anchor" href="#new-peerrpcserver(link%2C-%5Boptions%5D)">§</a> new PeerRPCServer(link, [options])</h4><ul><li><code>link</code> &lt;Object&gt; Instance of a <a href="#new-linkoptions">Link Class</a></li><li><code>options</code> &lt;Object&gt;<ul><li><code>secure</code> &lt;Object&gt; TLS options<ul><li><code>key</code> &lt;Buffer&gt; Key file content</li><li><code>cert</code> &lt;Buffer&gt; Cert file content</li><li><code>ca</code> &lt;Buffer&gt; Ca file content</li><li><code>rejectUnauthorized</code> &lt;Boolean&gt; Reject IPs / Hostnames not in cert’s list</li><li><code>requestCert</code> &lt;Boolean&gt; Request a certificate from a connecting client</li><li><code>verifyClient</code> &lt;Function&gt; Function to verify connecting client before Websocket connection is established.</li></ul></li></ul></li></ul><p>Creates a new instance of a <code>PeerRPCServer</code>, which connects to the DHT using the passed <code>link</code>.</p><h4 id="peer.init()"><a class="header-anchor" href="#peer.init()">§</a> peer.init()</h4><p>Sets the peer active. Must get called before we get a transport to set up a server.</p><h4 id="peer.transport(%E2%80%98server%E2%80%99)"><a class="header-anchor" href="#peer.transport(%E2%80%98server%E2%80%99)">§</a> peer.transport(‘server’)</h4><p>Must get called after the peer is active. Sets peer into server- mode.</p><h4 id="peer.listen(port)"><a class="header-anchor" href="#peer.listen(port)">§</a> peer.listen(port)</h4><p>Lets the <code>PeerRPCServer</code> listen on the desired <code>port</code>. The port is stored in the DHT.</p><h4 id="peer.port"><a class="header-anchor" href="#peer.port">§</a> peer.port</h4><p>Port of the server (set by <code>listen(port)</code>).</p><h3 id="class%3A-peerrpcclient"><a class="header-anchor" href="#class%3A-peerrpcclient">§</a> Class: PeerRPCClient</h3><h4 id="new-peerrpcclient(link%2C-%5Boptions%5D)"><a class="header-anchor" href="#new-peerrpcclient(link%2C-%5Boptions%5D)">§</a> new PeerRPCClient(link, [options])</h4><ul><li><code>link</code> &lt;Object&gt; Instance of a <a href="#new-linkoptions">Link Class</a></li><li><code>options</code> &lt;Object&gt;<ul><li><code>maxActiveKeyDests</code> &lt;Number&gt;</li><li><code>maxActiveDestTransports</code> &lt;Number&gt;</li><li><code>secure</code>: &lt;Object&gt; TLS options<ul><li><code>key</code> &lt;Buffer&gt; Key file content</li><li><code>cert</code> &lt;Buffer&gt; Cert file content</li><li><code>ca</code> &lt;Buffer&gt; Ca file content</li><li><code>rejectUnauthorized</code> &lt;Boolean&gt; Reject IPs / Hostnames not in cert’s list</li></ul></li></ul></li></ul><p>Creates a new instance of a <code>PeerRPCClient</code>, which connects to the DHT using the passed <code>link</code>.</p><p>A PeerRPCClient can communicate with multiple Servers and map work items over them. With <code>maxActiveKeyDests</code> you can limit the maximum amount of destinations. Additionally, you can limit the amount of transports with <code>maxActiveDestTransports</code>.</p><h4 id="peer.init()-2"><a class="header-anchor" href="#peer.init()-2">§</a> peer.init()</h4><p>Sets the peer active. Must get called before we start to make requests.</p><h4 id="peer.map(name%2C-payload%2C-%5Boptions%5D%2C-callback)"><a class="header-anchor" href="#peer.map(name%2C-payload%2C-%5Boptions%5D%2C-callback)">§</a> peer.map(name, payload, [options], callback)</h4><ul><li><code>name</code> &lt;String&gt; Name of the service to address</li><li><code>payload</code> &lt;String&gt; Payload to send</li><li><code>options</code> &lt;Object&gt; Options for the request<ul><li><code>timeout</code> &lt;Number&gt; timeout in ms</li><li><code>limit</code> &lt;Number&gt; maximum requests per available worker</li></ul></li><li><code>callback</code> &lt;Function&gt;</li></ul><p>Maps a number of requests over the amount of registered workers / PeerRPCServers.</p><p><a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/rpc_cert_whitelist_server.js">Example</a>.</p><h4 id="peer.request(name%2C-payload%2C-%5Boptions%5D%2C-callback)"><a class="header-anchor" href="#peer.request(name%2C-payload%2C-%5Boptions%5D%2C-callback)">§</a> peer.request(name, payload, [options], callback)</h4><ul><li><code>name</code> &lt;String&gt; Name of the service to address</li><li><code>payload</code> &lt;String&gt; Payload to send</li><li><code>options</code> &lt;Object&gt; Options for the request<ul><li><code>timeout</code> &lt;Number&gt; timeout in ms</li><li><code>retry</code> &lt;Number&gt; attempts to make before giving up. default is 1</li></ul></li><li><code>callback</code> &lt;Function&gt;</li></ul><p>Sends a single request to a RPC server/worker.</p><p><a href="https://github.com/bitfinexcom/grenache-nodejs-ws/tree/master/examples/rpc_cert_whitelist_client.js">Example</a>.</p></div></div><!--
      <div id="bfx-oss-docs-footer-bar">
        <div id="bfx-oss-docs-footer-bar__container">
          <p>Copyright © 2013-2020 iFinex Inc. All rights reserved.</p>
        </div>
      </div>
      --></div><script type="text/javascript" src="js/vendor/debug.min.js"></script><script type="text/javascript" src="js/vendor/lodash.min.js"></script><script type="text/javascript" src="js/vendor/zepto.min.js"></script><script type="text/javascript" src="js/vendor/perfect-scrollbar.min.js"></script><script type="text/javascript" src="js/main.js"></script></body></html>